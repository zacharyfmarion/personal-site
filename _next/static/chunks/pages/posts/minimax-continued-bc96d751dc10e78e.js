(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[36],{5820:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/minimax-continued",function(){return n(5225)}])},5225:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return c}});var i=n(5893),a=n(9232),r=n(2685),o=n(8702),s=n(7994),h=n(2627);let l=e=>{let{children:t}=e;return(0,i.jsx)(r.ZP,{...h.YO,children:t})};function d(e){let t={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,a.ah)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.jT,{children:(0,i.jsx)(t.p,{children:"Our minimax algorithm covered in the previous blog post will consistently\nproduce the optimal play for each player. There's only one problem - it's\nextremely slow. For a game of tic-tac-toe, with a relatively small state\nspace, this isn't a problem. However, for games like Chess and even Othello,\nthe state space becomes so large that running minimax quickly becomes\nimpractical. Running minimax on the opening state of a chess board would take\nhundreds of thousands if not millions of years to complete on consumer\nhardware. And you would run out of memory long before that. So how do we get\naround the problem of indeterminate runtimes due to game complexity? There are\nmany improvements that can be made to the base minimax algorithm. In this\npost, I will discuss two at length. Firstly, we will explore limiting the\ndepth of the algorithm, and secondly we will investigate alpha-beta pruning,\nan optimization of minimax that still ensures the algorithm's optimality."})}),"\n",(0,i.jsx)(t.h2,{children:"Depth Limited Minimax"}),"\n",(0,i.jsx)(t.p,{children:'As a quick reminder, the term "heuristic" is used to describe a function that approximates the favorabilty of a given state to the current player. For example, in chess a very naive heuristic could be the number of pieces the current player has minus the number of pieces the other player has. If this number is positive, the player is more likely to be winning, and if it is negative they are more likely to be losing. Actual chess engines use much more complex heuristics, but the basic concept is the same.'}),"\n",(0,i.jsx)(t.p,{children:"Assuming that we cannot actually traverse the entire state tree, we can simply traverse a fixed depth instead. Now our termination condition is either of the following:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The game is over (win, loss, or draw)"}),"\n",(0,i.jsx)(t.li,{children:"The maximum depth from the current state was reached"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"From here we score the leaf nodes based on a heuristic function, and perform the exact same minimax algorithm based on these values. It is important to note that a heuristic function's value for a given state does not necessary map correctly to the true minimax value of the state (assuming the entire state tree had been traversed). This means that suboptimal play could be produced by a depth-limited minimax algorithm. However, limiting the depth does allow us to apply minimax to a much broader set of games (such as chess) and still produce relatively good agents."}),"\n",(0,i.jsx)(t.h2,{children:"Alpha Beta Pruning"}),"\n",(0,i.jsx)(t.h3,{children:"Background"}),"\n",(0,i.jsx)(t.p,{children:"It turns out that the minimax algorithm visits a lot of unnnecessary states during its traversal. To be precise, it visits many states that could not correspond to the optimal play, given the current information available. To understand why this is, we first need to parse out the recursive execution of the algorithm. When explaining it before, I made it seem as though we found all the leaf nodes first, and then computed the next layer of values from these nodes. However, this is not actually how the algorithm executes. Minimax is recursive by nature, and so its execution essentially maps to a depth-first traversal of the state tree. If this is not familiar, a depth first seach can be explained best visually:"}),"\n",(0,i.jsx)(o.Z,{rootNode:"O",vertexMap:new Map([["O",["E","F","N"]],["E",["A","D"]],["F",[]],["N",["G","M"]],["A",[]],["D",["B","C"]],["G",[]],["M",["H","I","J","K","L"]],["B",[]],["C",[]],["H",[]],["I",[]],["J",[]],["K",[]],["L",[]]])}),"\n",(0,i.jsx)(t.p,{children:"Assuming we are going left to right, we essentially go all the way down the left side of the tree until we reach a leaf node. Once we reach that node, we go back up until we find a node that has other unvisited children. Once that node is found we repeat our previous step on that subtree, going all the way down the left until we reach a leaf, and then back up until we find a node with more univisted children. Eventually we will have reached all of the nodes in the tree, completing our traversal."}),"\n",(0,i.jsx)(t.p,{children:"Minimax essentially does this traversal, with the following modification: we go down the left of the tree until we reach a leaf. Score that leaf based on the outcome of the game (or the heuristic if we are doing a depth limited search). Then go back up the parent. If the parent's children have all been visited, then set the parent's value to the min or max of its children (depending on which player it is). If the parent has unvisited children, visit the leftmost child and repeat the above process. Eventually the value of the root will be set and the traversal is complete. Feel free to play around with the animation of this process to get a feel for how it works:"}),"\n",(0,i.jsx)(s.Z,{rootNode:"O",vertexMap:new Map([["O",["E","F","N"]],["E",["A","D"]],["F",[]],["N",["G","M"]],["A",[]],["D",["B","C"]],["G",[]],["M",["H","I","J","K","L"]],["B",[]],["C",[]],["H",[]],["I",[]],["J",[]],["K",[]],["L",[]]]),rewards:new Map([["F",1],["A",5],["G",4],["B",-1],["C",3],["H",-4],["I",9],["J",2],["K",-9],["L",1]])}),"\n",(0,i.jsx)(t.p,{children:"Note that we are computing the max and min of the children in a subtly different way here. Instead of creating an array of the child values and taking the min or max of that, we iterate over the children of a node in some specific order. For example when computing the max of the nodes in the bottom right ([-4, 1, 2, -9, 9]), we go from left to right, keeping track of the highest value we have seen."}),"\n",(0,i.jsx)(t.h3,{children:"The Algorithm"}),"\n",(0,i.jsx)(t.p,{children:"With this in mind, we can now jump into alpha-beta pruning. Looking at the same example, we are actually visiting some states unnnecessarily. Zooming in on the left subtree of our graph,"}),"\n",(0,i.jsx)(s.Z,{alphaBeta:!0,rootNode:"O",vertexMap:new Map([["O",["E","F","N"]],["E",["A","D"]],["F",[]],["N",["G","M"]],["A",[]],["D",["B","C"]],["G",[]],["M",["H","I","J","K","L"]],["B",[]],["C",[]],["H",[]],["I",[]],["J",[]],["K",[]],["L",[]]]),rewards:new Map([["F",1],["A",5],["G",4],["B",-1],["C",3],["H",-4],["I",9],["J",2],["K",-9],["L",1]])}),"\n",(0,i.jsxs)(t.p,{children:["It is important to note that the states that are considered unnnecessary are entirely dependent on the traversal order. For example, If we visited the children of node K [TODO THIS DOESN'T WORK HERE] (the one with the value 9) in the order ",(0,i.jsx)(t.code,{children:"[-4, 2, -9, 1, 9]"}),", none of the would be unnecessary as the only value we find that is greater than 4 is the final value, 9."]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,i.jsx)(l,{...e,children:(0,i.jsx)(d,{...e})})}},8702:function(e,t,n){"use strict";n.d(t,{Z:function(){return x}});var i=n(5893),a=n(7294),r=n(773),o=n.n(r),s=n(964),h=n(1642),l=n.n(h),d=n(204);let c=(e,t,n)=>{for(let i of e.get(t)||[])if(!n.get(i))return i;return null},u=e=>{let t=e[e.length-1];return{arrows:t?t.arrows.slice():[],active:t?t.active.slice():[]}},p=e=>{let{vertexMap:t,node:n,parent:i,states:a,visited:r}=e;if(null===n)return;r.set(n,!0);let o=t.get(n)||[];for(let e=0;e<o.length;e++){let i=o[e],{arrows:s,active:h}=u(a);s.push({node1:n,node2:i,up:!1}),null===c(t,i,r)&&h.push(i),a.push({arrows:s,active:h}),p({vertexMap:t,node:i,parent:n,states:a,visited:r});let l=u(a);s=l.arrows,h=l.active,s.push({node1:i,node2:n,up:!0}),e===o.length-1&&h.push(n),a.push({arrows:s,active:h})}};var m=n(1995),f=n(8979),w=n(8610);class g extends a.Component{render(){let{vertexMap:e,rootNode:t,onError:n,treeOptions:a}=this.props;return(0,i.jsx)(v,{states:this.getStates(),children:r=>{let{arrows:o,active:s}=r;return(0,i.jsx)(l(),{width:200,height:85,rootId:t,nodeSize:5,vertices:e,levelSeparation:20,maxDepth:1/0,siblingSeparation:15,subtreeSeparation:15,onError:n,...a,children:e=>{let{x:n,y:a,id:r,graph:h}=e;return(0,i.jsxs)("g",{children:[r===t&&this.renderArrows(h,o),(0,i.jsx)("circle",{cx:n,cy:r===t?a+1:a,r:5,fill:s.includes(r)?"rgb(15, 98, 189)":"white",stroke:"black","stroke-width":.5}),(0,i.jsx)(w.Z,{x:n,y:r===t?a+1:a,label:r,color:s.includes(r)?"white":"black"})]})}})}})}constructor(...e){super(...e),this.getStates=()=>{let e=[{active:[],arrows:[]}],{vertexMap:t,rootNode:n}=this.props;return p({states:e,vertexMap:t,node:n,parent:null,visited:new Map,active:[],arrows:[]}),e},this.renderArrows=o()((e,t)=>t.map(t=>{let{node1:n,node2:a,up:r}=t;return(0,i.jsx)(m.Z,{...(0,d.Z)(e,n,a,r),color:"lightgray"})}))}}let v=(0,s.default)(f.Z).withConfig({componentId:"sc-51db1148-0"})(["width:100%;"]);var x=g}},function(e){e.O(0,[869,34,609,685,994,774,888,179],function(){return e(e.s=5820)}),_N_E=e.O()}]);